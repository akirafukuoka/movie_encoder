package com.akirafukuoka {	import com.akirafukuoka.Block;	import flash.display.BitmapData;	import flash.geom.Rectangle;	import flash.geom.Point;		public class Blocks {		private var _frame:int = 0;		private var _timeCode:Number = 0;		private var _block:Block;		private var _array:Array = [];		private var _p_width:Number = 0;		private var _p_height:Number = 0;				private var _totalFrames:int = 0;		private var _threshold:Number = 0.1;		private var _threshold2:Number = 10;		public function Blocks(w_num:int,h_num:int,p_width:Number, p_height:Number, threshold:Number,threshold2:Number) {			// constructor code			_p_width = p_width;			_p_height = p_height;			_threshold = threshold;			_threshold2 = threshold2;			for(var i:int=0;i<w_num;i++){				_array[i] = [];				for(var k:int=0;k<h_num;k++){					_array[i][k] = new Block(i,k,_threshold,_threshold2);				}			}		}		public function getBlock(w_num:int,h_num:int):Block {			return _array[w_num][h_num];		}		public function getBlockBitmapData(w_num:int,h_num:int,num:int):BitmapData {			return _array[w_num][h_num].getBitmapData(num);		}		public function pushBlockBitmapData(w_num:int, h_num:int, bmpd:BitmapData):int {			return _array[w_num][h_num].pushBitmapData(bmpd);		}		public function set totalFrames(num:int):void{			_totalFrames = num;		}		public function get totalFrames():int{			 return _totalFrames;		}		public function publishOutputBitmapData():BitmapData {			var total:int = 0;			for(var i:int=0;i<_array.length;i++){				for(var k:int=0;k<_array[i].length;k++){					total += _array[i][k].length;				}			}			_totalFrames = total;						//var max_width:int = 1414;			var max_width:int = 1732;						var total_w:int = Math.floor(Math.sqrt(total));			if(total_w*_p_width > max_width) {				total_w = Math.floor(max_width/_p_width);			}			var full_h:int = Math.ceil(total / total_w);			var total_h:int = full_h;			/*			if(total_h*_p_height > 1414) {				total_h = Math.floor(1414/_p_height);			}			*/			/*			while(total_w*total_h < total){				total_h++;			}			*/			/*			あまりを最小にする方法…だとうまく行かない（当然か）			var a:int = total;			var a2:int = 0;			for(i=1;i<Math.floor(total/2);i++){				a2 = ((total+1-i)*i)%total;				if(a > a2) {					a = a2;					total_w = (total+1-i);					total_h = i;				}			}			*/						var bmpd:BitmapData = new BitmapData(total_w*_p_width,total_h*_p_height,true,0x00000000);			var xNum:Number = 0;			var yNum:Number = 0;			var block:Block;			var point:Point;			for(i=0;i<_array.length;i++){				for(k=0;k<_array[i].length;k++){					block = _array[i][k];					for(var h=0;h<_array[i][k].length;h++){						point = new Point(xNum*_p_width,yNum*_p_height);						block.setOutputPoint(h,point);						block.setOutputFrame(h, xNum+yNum*total_w);						bmpd.copyPixels(block.getBitmapData(h), new Rectangle(0,0,_p_width,_p_height), point);												xNum++;						if(xNum>=total_w){							xNum = 0;							yNum++;						}					}				}			}			return bmpd;		}			}	}