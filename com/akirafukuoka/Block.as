package com.akirafukuoka {	import flash.display.BitmapData;	import flash.geom.Point;		public class Block {		private var _bmpd:BitmapData;		private var _ox:int = 0;		private var _oy:int = 0;		private var _array:Array = [];		private var _outputPointArray:Array = [];				private var _outputXNum:int = 0;		private var _outputYNum:int = 0;				private var _outputFrame:Array = [];				private var _threshold:Number = 0.1;		private var _threshold2:Number = 10;				public function Block(x:int,y:int,threshold:Number,threshold2:Number) {			// constructor code			_ox = x;			_oy = y;			_threshold = threshold;			_threshold2 = threshold2;		}		public function get length():int {			return _array.length;		}		//書き出し画像のどの位置に書き出されたか		public function setOutputPoint(num:int,point:Point):void {			_outputPointArray[num] = point;		}		public function getOutputPoint(num:int):Point {			return _outputPointArray[num];		}		//書き出し画像の何フレーム目に書き出されたか		public function setOutputFrame(num:int,frame:int):void {			_outputFrame[num] = frame;		}		public function getOutputFrame(num:int):int {			return _outputFrame[num];		}		public function getBitmapData(num:int):BitmapData {			return _array[num];		}		public function pushBitmapData(bmpd:BitmapData):int {			var num = 0;			if(_array.length){				var difBool:Boolean = true;				for(var i:int = _array.length-1;i>=0 && _array.length-i <30;i--){					if(compareBitmapData(_array[i],bmpd,_threshold, _threshold2)){						//誤差 (_threshold) %想定ではじかれた場合						//検索続行					}else {						difBool = false;						break					}				}				if(difBool){					_array.push(bmpd.clone());					num = _array.length-1				}else{					num = i;				}			}else{				_array.push(bmpd.clone());			}			return num;		}				private function compareBitmapData(bmpd0:BitmapData,bmpd1:BitmapData, threshold:Number, threshold2:Number):Boolean{						var c:int = 0;			var d:int = 0;			var r:Boolean = false;			var border:int = bmpd0.width*bmpd0.height*(threshold/100);			for(var y:int = 0; y < bmpd0.height; y++){				for(var x:int = 0; x < bmpd0.width; x++){					if( comparePixels( bmpd0.getPixel32(x, y), bmpd1.getPixel32(x, y), threshold2 ) ){												d ++;						if(d>=border){							r = true							break;						}					}					else{						c ++;					}				}			}			return r;		}		private function comparePixels(a:int, b:int, threshold:int):Boolean{			var a_alp:int = a>>24&0xFF;			var b_alp:int = b>>24&0xFF;			var a_red:int = a>>16&0xFF;			var b_red:int = b>>16&0xFF;			var a_green:int = a>>8&0xFF;			var b_green:int = b>>8&0xFF;			var a_blue:int = a&0xFF;			var b_blue:int = b&0xFF;			if((a_alp > b_alp && a_alp-b_alp > threshold) || (a_alp < b_alp && b_alp-a_alp > threshold) ||				 (a_red > b_red && a_red-b_red > threshold) || (a_red < b_red && b_red-a_red > threshold) ||			   (a_green > b_green && a_green-b_green > threshold) || (a_green < b_green && b_green-a_green > threshold) ||			   (a_blue > b_blue && a_blue-b_blue > threshold) || (a_blue < b_blue && b_blue-a_blue > threshold)			   ) return true; // 色に差がある時			else return false; // 色に差が無い時		}	}	}